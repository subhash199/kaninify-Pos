<div class="@((IsVisible) ? "" : "d-none")">
    <!-- Backdrop to block clicks and visually separate the popup -->
    <div class="position-fixed top-0 start-0 w-100 h-100"
         style="z-index:1050; background-color: rgba(0,0,0,0.35);"></div>

    <!-- Popup content, elevated above everything else -->
    <div class="position-fixed top-50 start-50 translate-middle bg-white p-4 rounded shadow-lg"
         style="z-index:1060; max-height:80vh; overflow:auto;">
        <div class="mb-3">
            <label class="form-label">Enter Quantity:</label>
            <input type="number" @ref="quantityInput" class="form-control"
                   @bind="Value" @bind:event="oninput" />
        </div>

        <!-- If you embedded the number pad, keep it here -->
        <div class="mb-3">
            <NumberPadComponent OnNumberClick="HandleNumberClick" />
        </div>

        <div class="d-flex justify-content-end gap-2">
            <button class="btn btn-secondary on-hover-color" @onclick="Cancel">Cancel</button>
            <button class="btn btn-primary" @onclick="Apply">Apply</button>
        </div>
    </div>
</div>

@code {
    private ElementReference quantityInput;

    [Parameter] public bool IsVisible { get; set; }
    [Parameter] public string Value { get; set; } = "";
    [Parameter] public EventCallback OnApply { get; set; }
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    // Handle number pad clicks and reuse Value/ValueChanged
    private async Task HandleNumberClick(string number)
    {
        if (string.Equals(number, "Clear", StringComparison.OrdinalIgnoreCase))
        {
            Value = "";
        }
        else
        {
            if (int.TryParse(number, out _))
            {
                Value += number;
            }
        }

        await ValueChanged.InvokeAsync(Value);
        StateHasChanged();
    }

    private async Task Cancel()
    {
        IsVisible = false;
        await OnClose.InvokeAsync();
    }

    private async Task Apply()
    {
        await ValueChanged.InvokeAsync(Value);
        await OnApply.InvokeAsync();
        IsVisible = false;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (IsVisible)
        {
            await quantityInput.FocusAsync();
        }
    }
}